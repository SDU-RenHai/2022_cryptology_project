实现思路
===
 * **定义Merkle Tree的类结构**  
 包括左子节点、右子节父节点、兄弟节点、是否为根节点、是否为父节点的左子树、本节点的值、Hash值等。
 * **构造Merkle Tree**  
 输入叶子节点列表，返回根节点。对于叶子节点中的每一个数值，把第`i`个当作左子节点，并且修改它的类结构中的左子节点标记，第`i+1`个作为右子节点，如果最后有节点剩余，就把它放到树的上一层进行计算，需要注意，在最底层计算时，需要加上前缀`0x00`。把第`i`个和`i+1`个的Hash值级联在一起进行Hash操作，作为他们父节点的值，补全父节点和左右子节点类结构中的对应关系，需要注意，树节点在计算时需要加上前缀`0x01`。
 * **生成路径**  
 给定某一节点，生成根节点到该节点的路径及路径上经过节点的Hash值列表。若该节点有父节点，则先将该节点放入列表，用`'0'`表示；若该节点不是根节点，则将该节点的兄弟节点放入列表；若该节点是左子节点，则路径中用`'l'`表示，若该节点是右子节点，则路径中用`'r'`表示；循环遍历。
 * **验证节点**  
 首先生成该节点的路径，然后迭代验证路径上每一节点的Hash值是否正确。
 * **测试案例**  
 获取由`10w`个随机字符串组成的叶子节点列表，调用构造函数生成MerKle tree，然后指定某一结点为待验证节点，调用验证函数进行验证。
 

